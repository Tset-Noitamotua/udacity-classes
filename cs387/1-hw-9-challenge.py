# Decode the two ciphertexts from the Instructors Box below, 
# or the C1, C2 variables - which are the same
#
# We highly recommend that you run your decoding code in the 
# programming language of your choice outside of the 
# this environment, as this system does not provide enough 
# computational resources to successfully decode
#
# After decoding the two ciphertexts, 
# replace the plaintext1 and plaintext2 variables below
# with the decoded ciphertexts

# C1 and C2 are messages in english, 
# encoded using string_to_bits, with 7bit ASCII
# and then XOR'd with a secret key
#
# In pseudo-code:
# C1 = XOR(string_to_bits(plaintext1), secret_key)
# C2 = XOR(string_to_bits(plaintext2), secret_key)

C1 = "1010110010011110011111101110011001101100111010001111011101101011101000110010011000000101001110111010010111100100111101001010000011000001010001001001010000000010101001000011100100010011011011011011010111010011000101010111111110010011010111001001010101110001111101010000001011110100000000010010111001111010110000001101010010110101100010011111111011101101001011111001101111101111000100100001000111101111011011001011110011000100011111100001000101111000011101110101110010010100010111101111110011011011001101110111011101100110010100010001100011001010100110001000111100011011001000010101100001110011000000001110001011101111010100101110101000100100010111011000001111001110000011111111111110010111111000011011001010010011100011100001011001101110110001011101011101111110100001111011011000110001011111111101110110101101101001011110110010111101000111011001111"

C2 = "1011110110100110000001101000010111001000110010000110110001101001111101010000101000110100111010000010011001100100111001101010001001010001000011011001010100001100111011010011111100100101000001001001011001110010010100101011111010001110010010101111110001100010100001110000110001111111001000100001001010100011100100001101010101111000100001111101111110111001000101111111101011001010000100100000001011001001010000101001110101110100001111100001011101100100011000110111110001000100010111110110111010010010011101011111111001011011001010010110100100011001010110110001001000100011011001110111010010010010110100110100000111100001111101111010011000100100110011111011001010101000100000011111010010110111001100011100001111100100110010010001111010111011110110001000111101010110101001110111001110111010011111111010100111000100111001011000111101111101100111011001111"

#####
# CHANGE THESE VARIABLES

plaintext1 = "decoded message"
plaintext2 = "the other decoded message"

# END
#############

#############
# Below is some code that might be useful
#

BITS = ('0', '1')
ASCII_BITS = 7

def display_bits(b):
    """converts list of {0, 1}* to string"""
    return ''.join([BITS[e] for e in b])

def seq_to_bits(seq):
    return [0 if b == '0' else 1 for b in seq]

def pad_bits(bits, pad):
    """pads seq with leading 0s up to length pad"""
    assert len(bits) <= pad
    return [0] * (pad - len(bits)) + bits
        
def convert_to_bits(n):
    """converts an integer `n` to bit array"""
    result = []
    if n == 0:
        return [0]
    while n > 0:
        result = [(n % 2)] + result
        n = n / 2
    return result

def string_to_bits(s):
    def chr_to_bit(c):
        return pad_bits(convert_to_bits(ord(c)), ASCII_BITS)
    return [b for group in 
            map(chr_to_bit, s)
            for b in group]

def bits_to_char(b):
    assert len(b) == ASCII_BITS
    value = 0
    for e in b:
        value = (value * 2) + int(e)
    return chr(value)

def list_to_string(p):
    return ''.join(p)

def bits_to_string(b):
    return ''.join([bits_to_char(b[i:i + ASCII_BITS]) 
                    for i in range(0, len(b), ASCII_BITS)])
def xor(m, k):
    r = []
    assert len(m) == len(k)
    for i in range(len(m)):
        if m[i] == k[i]:
            r.append(0)
        else:
            r.append(1)
    return r

def copy_to_key(k, s, pos):
    for i in range(len(s)):
        k[i+pos] = int(s[i])
    return k

def print_key(k, n, pos):
    for i in range(n):
        print k[i+pos],
    print ''

def key_to_string(k):
    return ''.join(map(str, k))

key = [0 for i in range(len(C1))]
#key = copy_to_key(key, '1011000100101000011011010110011011011111001100101', 427)
#key = copy_to_key(key, '01100000101101000100101011111111101', 630)
#key = copy_to_key(key, '001101001100000101101000100101011111110001', 623)
#key = copy_to_key(key, '1110001110111000111000001101', 658)
#key = copy_to_key(key, '01000110000000101101100110100110000010110100010010101111111000111011100011100000110100101011110101111000101111010110010', 602)
#key = copy_to_key(key, '0011011101110000100100000001100000010010001001110011111100011010010111100110101110001100011100110001101011101011000010011010110100001100110101011001000111010000010001101011111010101101100100110010010001111000001110100111011100110111100010010010001110111011111010011001001010000011110100000010110011011100000100101100111000100111100001001110000000010101111100110111011100010011001011000100101000011011010110011011011111000110110101101110100111010111101100110111111111001000001101101100101011000101010000111100000110001001111001000010110100111111110100011010001100000001011011001101001100000101101000100101011111110001110111000111000001101001010111101011110001', 49)
#key = copy_to_key(key, '001011110010010110110000000110111011010110111000100000001011101000011110001000000011100011000000000111000000110100111101001101', 0)
#key = copy_to_key(key, '0010001111100100110110010101110101100010001010100001111101001001011101011101110000011011100001010111100111100001', 735)
#key = copy_to_key(key, '0111100011111011111011011110101001000110011010100110100000000111011111001111101110011010000010111110000101010011001010011100111100110', 714)
key = copy_to_key(key, '0010111100100101101100000001101110110101101110001000000010111010000111100010000000111000110000000001110000001101001111010011011101010110011100001000110001111011110011011101000010110000000000111110101101001001011001001001111001001011110111111111101100101111011011110011010100010000111001111010110100000100101001001100100010001100111001100011011100111010001100010000011000110110110000100110001100101100110101111001101000111001110101100010001100010001101110001111101100110011011010101110011010100010100110110011011011011001011000110001010010110001011000100111110111111100101101000011101001111110001110110111001010001110000100110010010110000010010000110001101010011110011000000011001100010100011111110010111101011000000110010011011000101110011001111100100110110010101110101100010001010100001111101001001011101011101110000011011100001010111100111100110', 0)
key = copy_to_key(key, '11000000111100011111011111011011110101001000110011010100110100000000111011111001111101110011010000010111110000101010011001010011100111100110', 707)
c1 = map(int, list(C1))
c2 = map(int, list(C2))
print 'plaintext1 = "'
print bits_to_string(xor(c1, key))
print 'plaintext2 = "'
print bits_to_string(xor(c2, key))

def try_sequence(s, e1, e2):
    import re
    englishtext = r"[A-Za-z0-9 \;\'\.\,\:\?\!\-\(\)]{" + str(len(s)) + "}"
    
    t = string_to_bits(s)
    l = len(s) * ASCII_BITS

    for i in range(0, len(e1)-l+1, ASCII_BITS):
        c1 = map(int, list(e1[i:i+l]))
        c2 = map(int, list(e2[i:i+l]))
        k = xor(t, c1)
        m1 = xor(c1, k)
        m2 = xor(c2, k)
        p1 = bits_to_string(m1)
        p2 = bits_to_string(m2)
        if re.match(englishtext, p2):
            print "%d/%d key: %s, p1: '%s', p2: '%s'" % (i, len(C1), key_to_string(k), p1, p2)

#for i in range(26):
#    try_sequence('the ' + chr(ord('a') + i), C1, C2)
try_sequence('Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin', C1, C2)
try_sequence('. (John von Neumann)', C1, C2)
